
# Rule based systems: Bagger

## Introduction

The primary purpose of this assignment is to learn to program in rule based, expert systems, specifically CLIPS.

## Problem Definition

Suppose that Robbie has been hired to bag groceries in a grocery store. Because he knows little about bagging groceries, he approaches his new job by creating Bagger, a rule-based production system that decides where each item should go.

## Program Design

The program design and pseudo code can be found in the “Bagger-Expert-Systems” PDF.

## Program
```SCHEME
;;; An item represents something to be bagged.
(deftemplate item
    (slot name
        (type SYMBOL))
    (slot container-type
        (type SYMBOL))
    (slot size
        (allowed-values small medium large))
    (slot frozen
        (allowed-values no yes)
            (default no)))

;;; New bag names are generated by keeping a counter, which is initializes to
;;; zero, and when we need a new bag we increment the counter and create a
;;; symbol by appending to the "bag". This is a purely procedural approach.
(defglobal ?*prev-bag-number* = 0)
(deffunction new-bag-name ()
    (bind ?*prev-bag-number* (+ ?*prev-bag-number* 1))
    (sym-cat bag ?*prev-bag-number*))

;;; The current bag has a name as well as the number and size of its contents.
;;; For bagger, bags only have items of a particular size. Note that current-bag
;;; self initializes - name defaults to the next bag name, item-count defaults
;;; to zero, and item-size initializes to nil, which won't match any known size.
(deftemplate bag
    (slot name
        (type SYMBOL)
            (default-dynamic (new-bag-name)))
    (slot item-count
        (type INTEGER)
            (default 0))
    (slot item-size
        (type SYMBOL)))

;;; Bagged facts represent items that have been bagged.
(deftemplate bagged
    (slot item-name
        (type SYMBOL))
    (slot bag-name
        (type SYMBOL)))

;;; The initial facts for Bagger. Note that the pepsi is commented out. This
;;; allows you to test rule B1.
(deffacts initial
    (bag)
    (item (name bread) (container-type plastic-bag) (size medium))
    (item (name glop) (container-type jar) (size small))
    (item (name granola) (container-type cardboard-box) (size large))
    (item (name ice-cream) (container-type cardboard-carton) (size medium) (frozen yes))
    (item (name potato-chips) (container-type plastic-bag) (size medium))
    (item (name pepsi) (container-type bottle) (size large))
)

(defrule B0
=>
    (set-strategy complexity)
    (assert (step check-order)))

(defrule B1
    (step check-order)
    (item (name potato-chips))
    (not (item (name pepsi)))
=>
    (printout t "Do you want a bottle of Pepsi? ")
    (if (= (str-compare (upcase (readline t)) "YES") 0)
        then (assert (item (name pepsi) (container-type bottle) (size large)))))

;;;B2, 6, 10, 13 used to order Large -> Medium -> Small
(defrule B2
    ?step-fact <- (step check-order)
=>
    (retract ?step-fact)
    (assert (step bag-large-items)))

;Bag large bottles first
(defrule B3
    (step bag-large-items)
    ?item-fact <- (item (name ?item-name) (container-type bottle) (size large))
    ?current-bag-fact <- (bag (name ?bag-name) (item-count ?item-count&:
        (< ?item-count 6)))
=>
    (retract ?item-fact)
    (assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
    (modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size large)))

(defrule B4
    (step bag-large-items)
    ?item-fact <- (item (name ?item-name) (size large))
    ?current-bag-fact <- (bag (name ?bag-name) (item-count ?item-count&:
        (< ?item-count 6)))
=>
    (retract ?item-fact)
    (assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
    (modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size large)))

(defrule B5
    (step bag-large-items)
    (item (name ?item-name) (size large))
    ?current-bag-fact <- (bag)
=>
    (retract ?current-bag-fact)
    (assert (bag)))

(defrule B6
    ?step-fact <- (step bag-large-items)
=>
    (retract ?step-fact)
    (assert (step bag-medium-items)))

(defrule B7
    (step bag-medium-items)
    ?item-fact <- (item (name ?item-name) (size medium) (frozen yes))
    ?current-bag-fact <- (bag (name ?bag-name) (item-count ?item-count)
        (item-size ?item-size))
    (test (or (= ?item-count 0) (and (eq ?item-size medium) (< ?item-count 12))))
=>
    (retract ?item-fact)
    (assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
    (modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size medium)))

(defrule B8
    (step bag-medium-items)
    ?item-fact <- (item (name ?item-name) (size medium))
    ?current-bag-fact <- (bag (name ?bag-name) (item-count ?item-count)
        (item-size ?item-size))
    (test (or (= ?item-count 0) (and (eq ?item-size medium) (< ?item-count 12))))
=>
    (retract ?item-fact)
    (assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
    (modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size medium)))

(defrule B9
    (step bag-medium-items)
    (item (name ?item-name) (size medium))
    ?current-bag-fact <- (bag)
=>
    (retract ?current-bag-fact)
    (assert (bag)))

(defrule B10
    ?step-fact <- (step bag-medium-items)
=>
    (retract ?step-fact)
    (assert (step bag-small-items)))

(defrule B11
    (step bag-small-items)
    ?item-fact <- (item (name ?item-name) (size small))
    ?current-bag-fact <- (bag (name ?bag-name) (item-count ?item-count)
        (item-size ?item-size))
    (test (or (= ?item-count 0) (and (eq ?item-size small) (< ?item-count 18))))
=>
    (retract ?item-fact)
    (assert (bagged (item-name ?item-name) (bag-name ?bag-name)))
    (modify ?current-bag-fact (item-count (+ ?item-count 1)) (item-size small)))

(defrule B12
    (step bag-small-items)
    (item (name ?item-name) (size small))
    ?current-bag-fact <- (bag)
=>
    (retract ?current-bag-fact)
    (assert (bag)))

(defrule B13
    ?step-fact <- (step bag-small-items)
=>
    (retract ?step-fact)
    (assert (step done)))

;;;Logging.
(defrule log-bagged
    (declare (salience 10))
    (bagged (item-name ?item-name) (bag-name ?bag-name))
=>
    (printout t ?item-name " in " ?bag-name crlf))
(defrule log-in-freezer-bag
    (declare (salience 10))
    (in-freezer-bag ?item-name)
=>
    (printout t ?item-name " in freezer bag" crlf))
```

## Results

![RESULT](https://i.imgur.com/CZ1HMfi.png)

![RESULT](https://i.imgur.com/suufrT0.png)
 
## Conclusion

While rule based is a little odd, and some of the forcing ordering of rules is really wonky, its clear that rule based systems are great for the things they are great for. Having done this even once, I can see how much harder if not impossible to do in most standard langauges.

As a side note, I think the fact that I have some experience in functional languages made learning this a lot easier than it would have been before I ever learned Haskell/Racket.




